## Паттерн Decorator (Декоратер)
#### Название и классификация
   * *Название:* Decorator (декоратор) или Wrapper (обертка)
   * *Тип:* структурный
#### Назначение
  * *Функция паттерна:* динамически добавляет объекту новые обязанности.
  * *Обоснование и назначение*:  является гибкой альтернативой порождению подклассов с целью расширения функциональности.
#### Мотивация использования
  * Необходимость возложить дополнительные обязанности на отдельный объект, а не на класс в целом, - ситуация для использование декораторов.  
  * Например, библиотека для построения графических интерфейсов пользователя должна «уметь» добавлять новое свойство, скажем, рамку или новое поведение (например, возможность прокрутки к любому элементу интерфейса). 
  * Статическое, не гибкое решение: добавить новые обязанности допустимо с помощью наследования. При наследовании классу с рамкой вокруг каждого экземпляра подкласса будет рисоваться рамка -> клиент не может управлять оформлением компонента рамкой. 
  * Гибкое решение: поместить компонент в другой объект, называемый декоратором, который как раз и добавляет рамку. Декоратор следует интерфейсу декорируемого объекта, поэтому его присутствие прозрачно для клиентов компонента. Декоратор переадресует запросы внутреннему компоненту, но может выполнять и дополнительные действия (например, рисовать рамку) до или после переадресации. Поскольку декораторы прозрачны, они могут вкладываться друг в друга, добавляя тем самым любое число новых обязанностей.
#### Применимость
  * для динамического, прозрачного для клиентов добавления обязанностей объектам; 
  * для реализации обязанностей, которые могут быть сняты с объекта; 
  * когда расширение путем порождения подклассов по каким-то причинам неудобно или невозможно
    - Иногда приходится реализовывать много независимых расширений, так что порождение подклассов для поддержки всех возможных комбинаций приведет к комбинаторному росту их числа. 
    - В других случаях определение класса может быть скрыто или почему-либо еще недоступно, так что породить от него подкласс нельзя.
#### Структура
![](https://github.com/MarinaSvistunova/prog5/blob/master/img/decorator.png)
#### Участники
  * Component (VisualComponent) - компонент: 
    - определяет интерфейс для объектов, на которые могут быть динамически возложены дополнительные обязанности; 
  * ConcreteComponent (TextView) - конкретный компонент: 
    - определяет объект, на который возлагаются дополнительные обязанности; 
  * Decorator - декоратор: 
    - хранит ссылку на объект Component и определяет интерфейс, соответствующий интерфейсу Component; 
  * ConcreteDecorator (BorderDecorator, ScrollDecorator) - конкретный декоратор: 
    - возлагает дополнительные обязанности на компонент.
#### Отношения
Decorator переадресует запросы объекту Component. Может выполнять и дополнительные операции до и после переадресации. 
#### Результаты
  * большая гибкость, нежели у статического наследования. Гибкое добавление объекту новых обязанностей, в отличие от случая статического (множественного) наследования. Декоратор может добавлять и удалять обязанности во время выполнения программы. При использовании же наследования требуется создавать новый класс для каждой дополнительной обязанности, что ведет к увеличению числа классов и, как следствие, к возрастанию сложности системы. Кроме того, применение нескольких декораторов к одному компоненту позволяет произвольным образом сочетать обязанности. Декораторы позволяют легко добавить одно и то же свойство дважды.
  * позволяет избежать перегруженных функциями классов на верхних уровнях иерархии. Декоратор разрешает добавлять новые обязанности по мере необходимости. Вместо того чтобы пытаться поддержать все мыслимые возможности в одном сложном, допускающем разностороннюю настройку классе, вы можете определить простой класс и постепенно наращивать его функциональность с помощью декораторов. В результате приложение уже не платит за неиспользуемые функции. Нетрудно также определять новые виды декораторов независимо от классов, которые они расширяют, даже если первоначально такие расширения не планировались. При расширении же сложного класса обычно приходится вникать в детали, не имеющие отношения к добавляемой функции; 
  * декоратор и его компонент не идентичны. Декоратор действует как прозрачное обрамление. Но декорированный компонент все же не идентичен исходному. При использовании декораторов это следует иметь в виду; 
  * множество мелких объектов. При использовании в проекте паттерна декоратор нередко получается система, составленная из большого числа мелких объектов, которые похожи друг на друга и различаются только способом взаимосвязи, а не классом и не значениями своих внутренних переменных. Хотя проектировщик, разбирающийся в устройстве такой системы, может легко настроить ее, но изучать и отлаживать ее очень тяжело. 
#### Реализация
  * соответствие интерфейсов. Интерфейс декоратора должен соответствовать интерфейсу декорируемого компонента. Поэтому классы ConcreteDecorator должны наследовать общему классу (по крайней мере, в C++); 
  * отсутствие абстрактного класса Decorator. Нет необходимости определять абстрактный класс Decorator, если планируется добавить всего одну обязанность. Так часто происходит, когда вы работаете с уже существующей иерархией классов, а не проектируете новую. В таком случае ответственность за переадресацию запросов, которую обычно несет класс Decorator, можно возложить непосредственно на ConcreteDecorator; 
  * облегченные классы Component. Чтобы можно было гарантировать соответствие интерфейсов, компоненты и декораторы должны наследовать общему классу Component. Важно, чтобы этот класс был настолько легким, насколько возможно. Иными словами, он должен определять интерфейс, а не хранить данные. В противном случае декораторы могут стать весьма тяжеловесными, и применять их в большом количестве будет накладно. Включение большого числа функций в класс Component также увеличивает вероятность, что конкретным подклассам придется платить за то, что им не нужно; 
  * изменение облика, а не внутреннего устройства объекта. Декоратор можно рассматривать как появившуюся у объекта оболочку, которая изменяет его поведение. Альтернатива - изменение внутреннего устройства объекта, хорошим примером чего может служить паттерн стратегия. Стратегии лучше подходят в ситуациях, когда класс Component уже достаточно тяжел, так что применение паттерна декоратор обходится слишком дорого. В паттерне стратегия компоненты передают часть своей функциональности отдельному объекту-стратегии, поэтому изменить или расширить поведение компонента допустимо, заменив этот объект.
#### Известные применения
Во многих библиотеках для построения объектно-ориентированных интерфейсов пользователя декораторы применяются для добавления к виджетам графических оформлений. В качестве примеров можно назвать Interviews, ЕТ++ и библиотеку классов ObjectWorks\Smalltalk. 
Другие варианты применения паттерна декоратор - это класс DebuggingGlyph из библиотеки Interviews и PassivityWrapper из ParcPlace Smalltalk. DebuggingGlyph печатает отладочную информацию до и после того, как переадресует запрос на размещение своему компоненту. Эта информация может быть полезна для анализа и отладки стратегии размещения объектов в сложном контейнере. Класс PassivityWrapper позволяет разрешить или запретить взаимодействие компонента с пользователем. 
#### Родственные паттерны
  * Адаптер: 
    - декоратор изменяет только обязанности объекта, но не его интерфейс
    - адаптер придает объекту совершенно новый интерфейс
  * Компоновщик: 
    - декоратор можно считать вырожденным случаем составного объекта, у которого есть только один компонент. Однако декоратор добавляет новые обязанности, агрегирование объектов не является его целью.
  * Стратегия: (ваимодополняющие способы изменения объекта)
    - декоратор позволяет изменить внешний облик объекта
    - стратегия - внутреннее содержание объекта
